---
layout : post
title : Assembly Language
date : 2018-06-06
tags : nand2tetris computer
---


# Assembly Language

*Han Zhilei*

â€‹	Having built the entire functional Hack computer,this chapter advances towards the hardware-binded control method of the computer, which is **assembly language**. It's our first stop in the journey through the *software layer*.*NOTE* the order has been rearranged,and this chapter is corresponded with original chapter 4.

![Logic Model](../assets/images/2018/logicmodel.png)

## Introduction

Congratulations on your completed implementation of the Hack computer. It's fully functional,and also,powerful. We originate from **Nand** gate only to build the whole computer and adopt Harvard architecture ,which faclitates matters when we look into the underlying structure.Here's a graph to make your memory of **computer architecture** come back.[1] 

![Harvard](../assets/images/2018/Harvard.png)

We're now going to build our software layers and this chapter will discuss the language that directly generated by hardware implementation and design an assembly language. In the end,we shall be capable to get the machine running as instructed.

###What is program?

Instruction memory,or *ROM*, is where the instructions are stored. Recall the design of our Hack computer,and you may remember the **Reset** button on the surface of the computer,which will redirect PC to be 0 - equally restart the program. Computer reads instructions in ROM according to the content of PC,and all the instructions form the *program*.

Since you have already built the computer,it's quite easy to find the instructions can be classified into 2 kinds: One kind changes the content of A-register,while another carries out operations. You can divide the latter into 2 aspects as well :either jump among the instructions of the program or conduct arithmetical&logical operation.

What we use to encode our program is machine-binded string of 0s and 1s,computer explicitly obey the codes.We call them **Machine language**,because of its direct connection with the underlying hardware platform.

### What is programming?

Generally speaking,what we are going to do in following chapters is **all about solving problems by programming**. When we already have the computer running,how to translate mental thought or concept to machine-undertstandable notation by programming is the case. A graph below summarizes the general process.[2]

![process](../assets/images/2018/process.png)

As you can see,machine language serves as the fundamental of the software layer as well as the interface for hardware. We can prove that anything a computer can do is able to be expressed by this language.When we are **programming**,the code produced all originate from machine language. What we will do is just facilitate the process of programming.

### Assembly:Why do we need it?

The difference between a machine and a human brain decides there should be higher level of language for programmers.**Assembly Language** is the most fundamental abstraction,which can be understood as mnemonic notation for the machine language. For instance , `1110001110000000` can be represented by `D-1`.

The design of assembly language is not fixed,but it should be tightly-binded to machine language. Generally speaking,a single assembly instruction is in correspondance with a single machine instruction,so there is no true difference between these two,because the **vocabulary** of the languages is the same - as stated before,jumping and operations - Just like :

```sequence
English->French:one to one
French->English:

English->Latin:several to one
Latin->English:
```

But we will see later that although unnecessary,the assembly language can provide utilities for *programmers*,for the sake of simplifying the **programming process**.

## Specification

In this part we will see how the Hack Assembly language is designed,and learn how to program using this language. A vast part of details in this section can be found in **Nand2Tetris textbook ,Section 4.2**. Although we rearrange the order of the chapters,it still throws light on the topic.

### A- and C- Instructions

As mentioned before,from the input of CPU,we classify the instructions to two kinds.In assembly language we define them to A- and C- instructions,respectively.

A-instruction is used to change the content of A register,its syntax is:

![ins](../assets/images/2018/AInstruction.png)

while C-instruction is used to carry out operation,jump through program and change the content of D and M register:

![ins](../assets/images/2018/CInstruction.png)

These two kinds of instructions are all user-friendly notation for corresponding machine code,as shown above.For more information,just refer to the Nand2Tetris textbook where more details are discussed.

### Expanded Utilities of Hack Assembly Language

It's unnecessary to provide more feature for assembly language, as is in the sentence *Keep it simple and stupid*.But with care,adding a few of them boost the process of programming. 

* The First Improvement: You may notice that **A,D,M** are all pre-defined symbol respectively referring to A-,D-,M- register.As long as we have symbols for certain RAM location,we can bring in more predefined ones to simplify the coding.You can refer to section 4.2.4 for more information.

* The Second Improvement: We should provide the feature that is the most useful.When programming using assembly,counting the number of instructions is the greatest nuisance. A good way to get rid of it is to define a "symbol" as well.But the symbol is not for register but for instruction,and we call it **label**. A label represent the next following instruction and can be referred to by jump operation. It greatly reduces the time for programming.

  Likewise,we can allow programmers to define own symbols for certain registers.The user-defined identifier (label or symbol) will make the process more automatic.See section 4.2.4 for more information

These **improvement** adds up to the power of the assembly language,by which improves the efficiency.

## Projects

After fully learned the principles of assembly language,try to write programs to carry out practical opearations using hack assembly language,with specification of the project described in section 4.4

## Additional points

#### completenesss of *mov*,and the instruction set

![mov](../assets/images/2018/mov.png)

**In previous chapter**,we have stated that  **Nand is complete** and **Add is complete**,.etc. What about the language part? Is a single instruction able to represent all the others?

*mov* is an instruction in [x86](https://en.wikipedia.org/wiki/X86) architecture,Stephen Dolan has proved that by using *mov* and using it only we can represent any process that a computer can do.[3]

However,just like we do not use Nand everytime we want to implement a chip,and do not use add always,we do not use a single instruction to carry out all the operations.Modern CPU takes several to thousands instructions as their input,and is divided to RISC and CISC accroding to the number of the instructions.Learn more from the link in [4].

## Summary

By learning how to write programs and what is programming using Hack Assembly language,you are supposed to have basic concept of what we will do in following chapters discussing more software abstraction layers. Before we advance to next layer,we have to implement all the features we learned here in next chapter,by a program called **assembler**.

## Reference

[1] Picture from http://www.toves.org/books/java/ch01-overview/index.html

[2] Picture from https://en.wikipedia.org/wiki/Harvard_architecture

[3] Stephen Dolan,mov is Turing-complete

[4] https://en.wikipedia.org/wiki/Reduced_instruction_set_computer

